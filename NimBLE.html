<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>$title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">zGlue SDK :: Alpha</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('NimBLE.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="contents">
<div class="textblock"><p class="">Bluetooth Host main configuration structure Those can be used by application to configure stack.</p>
<ol type="1">
<li>NIMBLE Overview 1.1 What is the Nimble? Apache Mynewt offers the world’s first fully open-source Bluetooth Low Energy (BLE) or Bluetooth Smart stack fully compliant with Bluetooth 5 specifications with support for Bluetooth Mesh. It is called NimBLE. BLE technology operates in the unlicensed industrial, scientific and medical (ISM) band at 2.4 to 2.485 GHz which is available in most countries. It uses a spread spectrum, frequency hopping, full-duplex signal. BLE FHSS employs 40 2-MHz-wide channels to ensure greater reliability over longer distances. It also features 0-dBm (1 mW) power output and a typical maximum range of 50 meters. With Bluetooth 5 specification range can be increased 4 times and speed 2 time. 1.2 Components A Bluetooth low energy stack (NimBLE included) consists of two components with several subcomponents: • Controller o Physical Layer: adaptive frequency-hopping Gaussian Frequency Shift Keying (GFSK) radio using 40 RF channels (0-39), with 2 MHz spacing. o Link Layer: with one of five states (Standby, Advertising, Scanning, Initiating, Connection states) active at any time • Host o Logical Link Control and Adaptation Protocol (L2CAP): provides logical channels, named L2CAP channels, which are multiplexed over one or more logical links to provide packet segmentation and reassembly, flow control, error control, streaming, QoS etc. o Security Manager (SM): uses Security Manager Protocol (SMP) for pairing and transport specific key distribution for securing radio communication o Attribute protocol (ATT): allows a device (Server) to expose certain pieces of data, known as Attributes, to another device (Client) o Generic Attribute Profile (GATT): a framework for using the ATT protocol to exchange attributes encapsulated as Characteristics or Services o Generic Access Profile (GAP): a base profile which all Bluetooth devices implement, which in the case of LE, defines the Physical Layer, Link Layer, L2CAP, Security Manager, Attribute Protocol and Generic Attribute Profile. o Host Controller Interface (HCI): the interface between the host and controller either through software API or by a hardware interface such as SPI, UART or USB.</li>
</ol>
<p class="">1.3 Nimble security The Bluetooth Low Energy security model includes five distinct security concepts as listed below. For detailed specifications, see BLUETOOTH SPECIFICATION Version 4.2 [Vol 1, Part A]. • Pairing: The process for creating one or more shared secret keys. In LE a single link key is generated by combining contributions from each device into a link key used during pairing. • Bonding: The act of storing the keys created during pairing for use in subsequent connections in order to form a trusted device pair. • Device authentication: Verification that the two devices have the same keys (verify device identity) • Encryption: Keeps message confidential. Encryption in Bluetooth LE uses AES-CCM cryptography and is performed in the Controller. • Message integrity: Protects against message forgeries. Bluetooth LE uses four association models depending on the I/O capabilities of the devices. • Just Works: designed for scenarios where at least one of the devices does not have a display capable of displaying a six digit number nor does it have a keyboard capable of entering six decimal digits. • Numeric Comparison: designed for scenarios where both devices are capable of displaying a six digit number and both are capable of having the user enter “yes” or “no”. A good example of this model is the cell phone / PC scenario. • Out of Band: designed for scenarios where an Out of Band mechanism is used to both discover the devices as well as to exchange or transfer cryptographic numbers used in the pairing process. • Passkey Entry: designed for the scenario where one device has input capability but does not have the capability to display six digits and the other device has output capabilities. A good example of this model is the PC and keyboard scenario.</p>
<ol type="1">
<li>Nimble API 2.1 Configure device address 2.1.1 Syscfg value set The NimBLE controller package exports a syscfg setting called BLE_PUBLIC_DEV_ADDR. This setting can be overridden at the application or target level to configure a public Bluetooth address. For example, a target can assign the public address 11:22:33:44:55:66 as follows: Syscfg.h: #ifndef MYNEWT_VAL_BLE_PUBLIC_DEV_ADDR #define MYNEWT_VAL_BLE_PUBLIC_DEV_ADDR (uint8_t[6]){0x66, 0x55, 0x44, 0x33, 0x22, 0x11}) #endif This setting takes the form of a C expression. Specifically, the value is a designated initializer expressing a six-byte array. Also note that the bytes are reversed, as an array is inherently little-endian, while addresses are generally expressed in big-endian.</li>
</ol>
<p class="">2.1.2 Configure a random address at runtime Random addresses get configured through the NimBLE host. The following two functions are used in random address configuration: ble_hs_id_gen_rnd: Generates a new random address. ble_hs_id_set_rnd: Sets the device’s random address.</p>
<p class="">2.2 HAL API Initialize the nimble hal layer module，include HW, OS, host and controller. void nimble_hal_init（void）;</p>
<p class="">Ensure functions only gets called one time during nimble initialization. void nimble_sysinit_start(void); void nimble_sysinit_end(void);</p>
<p class="">2.3 Host API 2.3.1 Host GAP API Searches for a connection with the specified handle. If a matching connection is found, the supplied connection descriptor is filled correspondingly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The connection handle to search for. </td></tr>
    <tr><td class="paramname">out_desc</td><td>On success, this is populated with information relating to the matching connection. Pass NULL if you don't need this information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, BLE_HS_ENOTCONN if no matching connection was found. int ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc out_desc);</dd></dl>
<p>This function configures and start advertising procedure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">own_addr_type</td><td>The type of address the stack should use for itself. Valid values are:<ul>
<li>BLE_OWN_ADDR_PUBLIC</li>
<li>BLE_OWN_ADDR_RANDOM</li>
<li>BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT</li>
<li>BLE_OWN_ADDR_RPA_RANDOM_DEFAULT </li>
</ul>
</td></tr>
    <tr><td class="paramname">direct_addr</td><td>The peer's address for directed advertising. his parameter shall be non-NULL if directed advertising is being used. </td></tr>
    <tr><td class="paramname">duration_ms</td><td>The duration of the advertisement procedure. On expiration, the procedure ends and a BLE_GAP_EVENT_ADV_COMPLETE event is reported. Units are milliseconds. Specify BLE_HS_FOREVER for no expiration. </td></tr>
    <tr><td class="paramname">adv_params</td><td>Additional arguments specifying the particulars of the advertising procedure. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to associate with this advertising procedure. If advertising ends, the event is reported through this callback. If advertising results in a connection, the connection inherits this callback as its event-reporting mechanism. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure. int ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t direct_addr, int32_t duration_ms, const struct ble_gap_adv_params adv_params, ble_gap_event_fn cb, void cb_arg);</dd></dl>
<p>Stops the currently-active advertising procedure. A success return code indicates that advertising has been fully aborted and a new advertising procedure can be initiated immediately. int ble_gap_adv_stop(void);</p>
<p class="">Indicates whether an advertisement procedure is currently in progress. </p><dl class="section return"><dt>Returns</dt><dd>0 if no advertisement procedure in progress, 1 otherwise. int ble_gap_adv_active(void);</dd></dl>
<p>Configures the data to include in subsequent advertisements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer containing the advertising data. </td></tr>
    <tr><td class="paramname">data_len</td><td>The size of the advertising data, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, BLE_HS_EBUSY if advertising is in progress, other error code on failure. int ble_gap_adv_set_data(const uint8_t data, int data_len);</dd></dl>
<p>Configures the data to include in subsequent scan responses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer containing the scan response data. </td></tr>
    <tr><td class="paramname">data_len</td><td>The size of the response data, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, BLE_HS_EBUSY if advertising is in progress, other error code on failure. int ble_gap_adv_rsp_set_data(const uint8_t data, int data_len);</dd></dl>
<p>Configures the fields to include in subsequent advertisements. This is a convenience wrapper for ble_gap_adv_set_data(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adv_fields</td><td>Specifies the advertisement data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, BLE_HS_EBUSY if advertising is in progress, BLE_HS_EMSGSIZE if the specified data is too large to fit in an advertisement, other error code on failure. int ble_gap_adv_set_fields(const struct ble_hs_adv_fields rsp_fields);</dd></dl>
<p>Configures the fields to include in subsequent scan responses. This is a convenience wrapper for ble_gap_adv_rsp_set_data(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adv_fields</td><td>Specifies the scan response data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, BLE_HS_EBUSY if advertising is in progress, BLE_HS_EMSGSIZE if the specified data is too large to fit in a scan response, other error code on failure. int ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields rsp_fields);</dd></dl>
<p>Performs the Limited or General Discovery Procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">own_addr_type</td><td>The type of address the stack should use for itself when sending scan requests. Valid values are:<ul>
<li>BLE_ADDR_TYPE_PUBLIC</li>
<li>BLE_ADDR_TYPE_RANDOM</li>
<li>BLE_ADDR_TYPE_RPA_PUB_DEFAULT</li>
<li>BLE_ADDR_TYPE_RPA_RND_DEFAULT This parameter is ignored unless active scanning is being used. </li>
</ul>
</td></tr>
    <tr><td class="paramname">duration_ms</td><td>The duration of the discovery procedure. On expiration, the procedure ends and a BLE_GAP_EVENT_DISC_COMPLETE event is reported. Units are milliseconds. Specify BLE_HS_FOREVER for no expiration. </td></tr>
    <tr><td class="paramname">disc_params</td><td>Additional arguments specifying the particulars of the discovery procedure. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to associate with this discovery procedure. Advertising reports and discovery termination events are reported through this callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. int ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms, const struct ble_gap_disc_params disc_params, ble_gap_event_fn cb, void cb_arg); r reset, the variable x has the value 5. Initialized variable of this Cancels the discovery procedure currently in progress. A success return code indicates that scanning has been fully aborted; a new discovery or connect procedure can be initiated immediately. </dd>
<dd>
0 on success; BLE_HS_EALREADY if there is no discovery procedure to cancel; Other nonzero on unexpected error. int ble_gap_disc_cancel(void);</dd></dl>
<p>Indicates whether a discovery procedure is currently in progress. </p><dl class="section return"><dt>Returns</dt><dd>0: No discovery procedure in progress; 1: Discovery procedure in progress. int ble_gap_disc_active(void);</dd></dl>
<p>Initiates a connect procedure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">own_addr_type</td><td>The type of address the stack should use for itself during connection establishment.<ul>
<li>BLE_OWN_ADDR_PUBLIC</li>
<li>BLE_OWN_ADDR_RANDOM</li>
<li>BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT</li>
<li>BLE_OWN_ADDR_RPA_RANDOM_DEFAULT </li>
</ul>
</td></tr>
    <tr><td class="paramname">peer_addr</td><td>The address of the peer to connect to. If this parameter is NULL, the white list is used. </td></tr>
    <tr><td class="paramname">duration_ms</td><td>The duration of the discovery procedure. On expiration, the procedure ends and a BLE_GAP_EVENT_DISC_COMPLETE event is reported. Units are milliseconds. </td></tr>
    <tr><td class="paramname">conn_params</td><td>Additional arguments specifying the particulars of the connect procedure. Specify null for default values. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to associate with this connect procedure. When the connect procedure completes, the result is reported through this callback. If the connect procedure succeeds, the connection inherits this callback as its event-reporting mechanism. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_EALREADY if a connection attempt is already in progress; BLE_HS_EBUSY if initiating a connection is not possible because scanning is in progress; BLE_HS_EDONE if the specified peer is already connected; Other nonzero on error. int ble_gap_connect(uint8_t own_addr_type, const ble_addr_t peer_addr, int32_t duration_ms, const struct ble_gap_conn_params params, ble_gap_event_fn cb, void cb_arg);</dd></dl>
<p>Aborts a connect procedure in progress. </p><dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_EALREADY if there is no active connect procedure. Other nonzero on error. int ble_gap_conn_cancel(void);</dd></dl>
<p>Indicates whether a connect procedure is currently in progress. </p><dl class="section return"><dt>Returns</dt><dd>0: No connect procedure in progress; 1: Connect procedure in progress.</dd></dl>
<p>int ble_gap_conn_active(void);</p>
<p class="">Terminates an established connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The handle corresponding to the connection to terminate. </td></tr>
    <tr><td class="paramname">hci_reason</td><td>The HCI error code to indicate as the reason for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_ENOTCONN if there is no connection with the specified handle; Other nonzero on failure. int ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason);</dd></dl>
<p>Initiates the GAP security procedure. Depending on connection role and stored security information this function will start appropriate security procedure (pairing or encryption). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The handle corresponding to the connection to secure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_ENOTCONN if the there is no connection with the specified handle; BLE_HS_EALREADY if an security procedure for this connection is already in progress; Other nonzero on error. int ble_gap_security_initiate(uint16_t conn_handle);</dd></dl>
<p>2.3.2 Host GATT API</p>
<p class="">Adjusts a host configuration object's settings to accommodate the specified service definition array. This function adds the counts to the appropriate fields in the supplied configuration object without clearing them first, so it can be called repeatedly with different inputs to calculate totals. Be sure to zero the GATT server settings prior to the first call to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defs</td><td>The service array containing the resource definitions to be counted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_EINVAL if the svcs array contains an invalid resource definition. int ble_gatts_count_cfg(const struct ble_gatt_svc_def defs);</dd></dl>
<p>Queues a set of service definitions for registration. All services queued in this manner get registered when ble_gatts_start() is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">svcs</td><td>An array of service definitions to queue for registration. This array must be terminated with an entry whose 'type' equals 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; BLE_HS_ENOMEM on heap exhaustion. int ble_gattc_disc_all_chrs(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, ble_gatt_chr_fn cb, void cb_arg);</dd></dl>
<p><br />
 <br />
Initiates GATT procedure: Discover All Primary Services. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The connection over which to execute the procedure. </td></tr>
    <tr><td class="paramname">cb</td><td>The function to call to report procedure status updates; null for no callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. int ble_gattc_disc_all_svcs(uint16_t conn_handle, ble_gatt_disc_svc_fn cb, void cb_arg);</td></tr>
  </table>
  </dd>
</dl>
<p><br />
Initiates GATT procedure: Discover All Characteristics of a Service. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The connection over which to execute the procedure. </td></tr>
    <tr><td class="paramname">start_handle</td><td>The handle to begin the search at (generally the service definition handle). </td></tr>
    <tr><td class="paramname">end_handle</td><td>The handle to end the search at (generally the last handle in the service). </td></tr>
    <tr><td class="paramname">cb</td><td>The function to call to report procedure status updates; null for no callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. int ble_gattc_disc_all_chrs(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, ble_gatt_chr_fn cb, void cb_arg);</dd></dl>
<p>Initiates GATT procedure: Exchange MTU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The connection over which to execute the procedure. </td></tr>
    <tr><td class="paramname">cb</td><td>The function to call to report procedure status updates; null for no callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. int ble_gattc_exchange_mtu(uint16_t conn_handle, ble_gatt_mtu_fn cb, void cb_arg);</dd></dl>
<p>Initiates GATT procedure: Discover Characteristics by UUID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_handle</td><td>The connection over which to execute the procedure. </td></tr>
    <tr><td class="paramname">start_handle</td><td>The handle to begin the search at (generally the service definition handle). </td></tr>
    <tr><td class="paramname">end_handle</td><td>The handle to end the search at (generally the last handle in the service). </td></tr>
    <tr><td class="paramname">chr_uuid128</td><td>The 128-bit UUID of the characteristic to discover. </td></tr>
    <tr><td class="paramname">cb</td><td>The function to call to report procedure status updates; null for no callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The optional argument to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. int ble_gattc_disc_chrs_by_uuid(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, const ble_uuid_t uuid, ble_gatt_chr_fn cb, void cb_arg);</dd></dl>
<ol type="1">
<li>Nimble Data Struct</li>
</ol>
<p class="">3.1 BLE HOST Struct</p>
<p class="">struct ble_hs_cfg { </p><pre class="fragment">An optional callback that gets executed upon registration of each GATT
resource (service, characteristic, or descriptor).
ble_gatt_register_fn gatts_register_cb;


An optional argument that gets passed to the GATT registration
callback.
void gatts_register_arg;

Security Manager Local Input Output Capabilities 
uint8_t sm_io_cap;

@brief Security Manager OOB flag

 If set proper flag in Pairing Request/Response will be set.
unsigned sm_oob_data_flag:1;

@brief Security Manager Bond flag

 If set proper flag in Pairing Request/Response will be set. This results
 in storing keys distributed during bonding.
unsigned sm_bonding:1;

@brief Security Manager MITM flag

If set proper flag in Pairing Request/Response will be set. This results
in requiring Man-In-The-Middle protection when pairing.
unsigned sm_mitm:1;

@brief Security Manager Secure Connections flag

 If set proper flag in Pairing Request/Response will be set. This results
 in using LE Secure Connections for pairing if also supported by remote
 device. Fallback to legacy pairing if not supported by remote.
 unsigned sm_sc:1;

@brief Security Manager Key Press Notification flag
Currently unsupported and should not be set.
unsigned sm_keypress:1;

@brief Security Manager Local Key Distribution Mask
uint8_t sm_our_key_dist;

@brief Security Manager Remote Key Distribution Mask 
uint8_t sm_their_key_dist;

@brief Stack reset callback
 This callback is executed when the host resets itself and the controller
  due to fatal error.
  ble_hs_reset_fn reset_cb;

@brief Stack sync callback
 This callback is executed when the host and controller become synced.
 This happens at startup and after a reset.
 ble_hs_sync_fn sync_cb;

XXX: These need to go away. Instead, the nimble host package should
require the host-store API (not yet implemented)..
Storage Read callback handles read of security material 
ble_store_read_fn store_read_cb;

Storage Write callback handles write of security material 
ble_store_write_fn store_write_cb;

Storage Delete callback handles deletion of security material 
ble_store_delete_fn store_delete_cb;

@brief Storage Status callback.
 This callback gets executed when a persistence operation cannot be
  performed or a persistence failure is imminent. For example, if is
  insufficient storage capacity for a record to be persisted, this
  function gets called to give the application the opportunity to make
  room.
  ble_store_status_fn store_status_cb;

An optional argument that gets passed to the storage status callback. 
void store_status_arg;
</pre><p> }</p>
<p class="">3.2 NIMBLE GAP Data Struct</p>
<p class="">Connection security state struct ble_gap_sec_state { If connection is encrypted unsigned encrypted:1;</p>
<p class="">If connection is authenticated unsigned authenticated:1;</p>
<p class="">If connection is bonded (security information is stored) <br />
 unsigned bonded:1;</p>
<p class="">Size of a key used for encryption unsigned key_size:5; };</p>
<p class="">Advertising parameters struct ble_gap_adv_params { Advertising mode. Can be one of following constants:</p><ul>
<li>BLE_GAP_CONN_MODE_NON (non-connectable; 3.C.9.3.2).</li>
<li>BLE_GAP_CONN_MODE_DIR (directed-connectable; 3.C.9.3.3).</li>
<li>BLE_GAP_CONN_MODE_UND (undirected-connectable; 3.C.9.3.4).</li>
</ul>
<p class=""><br />
 uint8_t conn_mode; Discoverable mode. Can be one of following constants:</p><ul>
<li>BLE_GAP_DISC_MODE_NON (non-discoverable; 3.C.9.2.2).</li>
<li>BLE_GAP_DISC_MODE_LTD (limited-discoverable; 3.C.9.2.3).</li>
<li>BLE_GAP_DISC_MODE_GEN (general-discoverable; 3.C.9.2.4).</li>
</ul>
<p class=""><br />
 uint8_t disc_mode;</p>
<p class="">Minimum advertising interval, if 0 stack use sane defaults uint16_t itvl_min; Maximum advertising interval, if 0 stack use sane defaults uint16_t itvl_max; Advertising channel map , if 0 stack use sane defaults uint8_t channel_map;</p>
<p class="">Advertising Filter policy uint8_t filter_policy;</p>
<p class="">If do High Duty cycle for Directed Advertising uint8_t high_duty_cycle:1; }; Connection descriptor struct ble_gap_conn_desc { Connection security state struct ble_gap_sec_state sec_state;</p>
<p class="">Local identity address ble_addr_t our_id_addr;</p>
<p class="">Peer identity address ble_addr_t peer_id_addr;</p>
<p class="">Local over-the-air address ble_addr_t our_ota_addr;</p>
<p class="">Peer over-the-air address ble_addr_t peer_ota_addr;</p>
<p class="">Connection handle uint16_t conn_handle;</p>
<p class="">Connection interval uint16_t conn_itvl;</p>
<p class="">Connection latency uint16_t conn_latency;</p>
<p class="">Connection supervision timeout uint16_t supervision_timeout;</p>
<p class="">Connection Role Possible values BLE_GAP_ROLE_SLAVE or BLE_GAP_ROLE_MASTER</p>
<p class=""><br />
 uint8_t role;</p>
<p class="">Master clock accuracy uint8_t master_clock_accuracy; };</p>
<p class="">struct ble_gap_conn_params { uint16_t scan_itvl; uint16_t scan_window; uint16_t itvl_min; uint16_t itvl_max; uint16_t latency; uint16_t supervision_timeout; uint16_t min_ce_len; uint16_t max_ce_len; };</p>
<p class="">struct ble_gap_disc_params { uint16_t itvl; uint16_t window; uint8_t filter_policy; uint8_t limited:1; uint8_t passive:1; uint8_t filter_duplicates:1; };</p>
<p class="">struct ble_gap_upd_params { uint16_t itvl_min; uint16_t itvl_max; uint16_t latency; uint16_t supervision_timeout; uint16_t min_ce_len; uint16_t max_ce_len; };</p>
<p class="">struct ble_gap_disc_desc { Common fields. uint8_t event_type; uint8_t length_data; ble_addr_t addr; int8_t rssi; uint8_t data;</p>
<pre class="fragment"> LE direct advertising report fields; direct_addr is BLE_ADDR_ANY if
 direct address fields are not present.

ble_addr_t direct_addr;
</pre><p> };</p>
<p class="">Represents a GAP-related event. When such an event occurs, the host notifies the application by passing an instance of this structure to an application-specified callback.</p>
<p class="">struct ble_gap_event { <br />
 Indicates the type of GAP event that occurred. This is one of the BLE_GAP_EVENT codes.</p>
<p class=""><br />
 uint8_t type;</p>
<p class=""><br />
 A discriminated union containing additional details concerning the GAP event. The 'type' field indicates which member of the union is valid.</p>
<p class=""><br />
 union { </p><pre class="fragment"> Represents a connection attempt.  Valid for the following event
 types:
     o BLE_GAP_EVENT_CONNECT

struct {

     The status of the connection attempt;
         o 0: the connection was successfully established.
         o BLE host error code: the connection attempt failed for
           the specified reason.

    int status;

    The handle of the relevant connection. 
    uint16_t conn_handle;
} connect;


 Represents a terminated connection.  Valid for the following event
 types:
     o BLE_GAP_EVENT_DISCONNECT

struct {

     A BLE host return code indicating the reason for the
     disconnect.

    int reason;

    Information about the connection prior to termination. 
    struct ble_gap_conn_desc conn;
} disconnect;


 Represents an advertising report received during a discovery
 procedure.  Valid for the following event types:
     o BLE_GAP_EVENT_DISC

struct ble_gap_disc_desc disc;
</pre><p class="">#if MYNEWT_VAL(BLE_EXT_ADV) </p><pre class="fragment">     Represents an extended advertising report received during a discovery
     procedure.  Valid for the following event types:
         o BLE_GAP_EVENT_EXT_DISC

    struct ble_gap_ext_disc_desc ext_disc;
</pre><p> #endif</p>
<pre class="fragment">     Represents a completed discovery procedure.  Valid for the following
     event types:
         o BLE_GAP_EVENT_DISC_COMPLETE

    struct {

         The reason the discovery procedure stopped.  Typical reason
         codes are:
             o 0: Duration expired.
             o BLE_HS_EPREEMPTED: Host aborted procedure to configure a
               peer's identity.

        int reason;
    } disc_complete;


     Represents a completed advertise procedure.  Valid for the following
     event types:
         o BLE_GAP_EVENT_ADV_COMPLETE

    struct {

         The reason the advertise procedure stopped.  Typical reason
         codes are:
             o 0: Terminated due to connection.
             o BLE_HS_ETIMEOUT: Duration expired.
             o BLE_HS_EPREEMPTED: Host aborted procedure to configure a
               peer's identity.

        int reason;
</pre><p class="">#if MYNEWT_VAL(BLE_EXT_ADV) Advertising instance uint8_t instance; The handle of the relevant connection - valid if reason=0 uint16_t conn_handle;</p>
<p class=""><br />
 Number of completed extended advertising events</p>
<p class=""><br />
 This field is only valid if non-zero max_events was passed to ble_gap_ext_adv_start() and advertising completed due to duration timeout or max events transmitted.</p>
<p class=""><br />
 uint8_t num_ext_adv_events; #endif } adv_complete;</p>
<pre class="fragment">     Represents an attempt to update a connection's parameters.  If the
     attempt was successful, the connection's descriptor reflects the
     updated parameters.

     Valid for the following event types:
         o BLE_GAP_EVENT_CONN_UPDATE

    struct {

         The result of the connection update attempt;
             o 0: the connection was successfully updated.
             o BLE host error code: the connection update attempt failed
               for the specified reason.

        int status;

        The handle of the relevant connection. 
        uint16_t conn_handle;
    } conn_update;


     Represents a peer's request to update the connection parameters.
     This event is generated when a peer performs any of the following
     procedures:
         o L2CAP Connection Parameter Update Procedure
         o Link-Layer Connection Parameters Request Procedure

     To reject the request, return a non-zero HCI error code.  The value
     returned is the reject reason given to the controller.

     Valid for the following event types:
         o BLE_GAP_EVENT_L2CAP_UPDATE_REQ
         o BLE_GAP_EVENT_CONN_UPDATE_REQ

    struct {

         Indicates the connection parameters that the peer would like to
         use.

        const struct ble_gap_upd_params peer_params;


         Indicates the connection parameters that the local device would
         like to use.  The application callback should fill this in.  By
         default, this struct contains the requested parameters (i.e.,
         it is a copy of 'peer_params').

        struct ble_gap_upd_params self_params;

        The handle of the relevant connection. 
        uint16_t conn_handle;
    } conn_update_req;


     Represents a failed attempt to terminate an established connection.
     Valid for the following event types:
         o BLE_GAP_EVENT_TERM_FAILURE

    struct {

         A BLE host return code indicating the reason for the failure.

        int status;

        The handle of the relevant connection. 
        uint16_t conn_handle;
    } term_failure;


     Represents an attempt to change the encrypted state of a
     connection.  If the attempt was successful, the connection
     descriptor reflects the updated encrypted state.

     Valid for the following event types:
         o BLE_GAP_EVENT_ENC_CHANGE

    struct {

         Indicates the result of the encryption state change attempt;
             o 0: the encrypted state was successfully updated;
             o BLE host error code: the encryption state change attempt
               failed for the specified reason.

        int status;

        The handle of the relevant connection. 
        uint16_t conn_handle;
    } enc_change;


     Represents a passkey query needed to complete a pairing procedure.

     Valid for the following event types:
         o BLE_GAP_EVENT_PASSKEY_ACTION

    struct {
        Contains details about the passkey query. 
        struct ble_gap_passkey_params params;

        The handle of the relevant connection. 
        uint16_t conn_handle;
    } passkey;


     Represents a received ATT notification or indication.

     Valid for the following event types:
         o BLE_GAP_EVENT_NOTIFY_RX

    struct {

         The contents of the notification or indication.  If the
         application wishes to retain this mbuf for later use, it must
         set this pointer to NULL to prevent the stack from freeing it.

        struct os_mbuf om;

        The handle of the relevant ATT attribute. 
        uint16_t attr_handle;

        The handle of the relevant connection. 
        uint16_t conn_handle;


         Whether the received command is a notification or an
         indication;
             o 0: Notification;
             o 1: Indication.

        uint8_t indication:1;
    } notify_rx;


     Represents a transmitted ATT notification or indication, or a
     completed indication transaction.

     Valid for the following event types:
         o BLE_GAP_EVENT_NOTIFY_TX

    struct {

         The status of the notification or indication transaction;
             o 0:                 Command successfully sent;
             o BLE_HS_EDONE:      Confirmation (indication ack) received;
             o BLE_HS_ETIMEOUT:   Confirmation (indication ack) never
                                      received;
             o Other return code: Error.

        int status;

        The handle of the relevant connection. 
        uint16_t conn_handle;

        The handle of the relevant characterstic value. 
        uint16_t attr_handle;


         Whether the transmitted command is a notification or an
         indication;
             o 0: Notification;
             o 1: Indication.

        uint8_t indication:1;
    } notify_tx;


     Represents a state change in a peer's subscription status.  In this
     comment, the term "update" is used to refer to either a notification
     or an indication.  This event is triggered by any of the following
     occurrences:
         o Peer enables or disables updates via a CCCD write.
         o Connection is about to be terminated and the peer is
           subscribed to updates.
         o Peer is now subscribed to updates after its state was restored
           from persistence.  This happens when bonding is restored.

     Valid for the following event types:
         o BLE_GAP_EVENT_SUBSCRIBE

    struct {
        The handle of the relevant connection. 
        uint16_t conn_handle;

        The value handle of the relevant characteristic. 
        uint16_t attr_handle;

        One of the BLE_GAP_SUBSCRIBE_REASON codes. 
        uint8_t reason;

        Whether the peer was previously subscribed to notifications. 
        uint8_t prev_notify:1;

        Whether the peer is currently subscribed to notifications. 
        uint8_t cur_notify:1;

        Whether the peer was previously subscribed to indications. 
        uint8_t prev_indicate:1;

        Whether the peer is currently subscribed to indications. 
        uint8_t cur_indicate:1;
    } subscribe;


     Represents a change in an L2CAP channel's MTU.

     Valid for the following event types:
         o BLE_GAP_EVENT_MTU

    struct {
        The handle of the relevant connection. 
        uint16_t conn_handle;


         Indicates the channel whose MTU has been updated; either
         BLE_L2CAP_CID_ATT or the ID of a connection-oriented channel.

        uint16_t channel_id;

        /The channel's new MTU. 
        uint16_t value;
    } mtu;


     Represents a change in peer's identity. This is issued after
     successful pairing when Identity Address Information was received.

     Valid for the following event types:
         o BLE_GAP_EVENT_IDENTITY_RESOLVED

    struct {
        The handle of the relevant connection. 
        uint16_t conn_handle;
    } identity_resolved;


     Represents a peer's attempt to pair despite a bond already existing.
     The application has two options for handling this event type:
         o Retry: Return BLE_GAP_REPEAT_PAIRING_RETRY after deleting the
                  conflicting bond.  The stack will verify the bond has
                  been deleted and continue the pairing procedure.  If
                  the bond is still present, this event will be reported
                  again.
         o Ignore: Return BLE_GAP_REPEAT_PAIRING_IGNORE.  The stack will
                   silently ignore the pairing request.

     Valid for the following event types:
         o BLE_GAP_EVENT_REPEAT_PAIRING

    struct ble_gap_repeat_pairing repeat_pairing;



     Represents a change of PHY. This is issue after successful
     change on PHY.

    struct {
        int status;
        uint16_t conn_handle;


         Indicates enabled TX/RX PHY. Possible values:
             o BLE_GAP_LE_PHY_1M
             o BLE_GAP_LE_PHY_2M
             o BLE_GAP_LE_PHY_CODED

        uint8_t tx_phy;
        uint8_t rx_phy;
    } phy_updated;
};
</pre><p> }</p>
<p class="">3.3 NIMBLE GATT Struct BLE gatt error struct. struct ble_gatt_error { uint16_t status; uint16_t att_handle; };</p>
<p class="">BLE gatt sevices struct. struct ble_gatt_svc { uint16_t start_handle; uint16_t end_handle; ble_uuid_any_t uuid; };</p>
<p class="">BLE gatt attribution struct. struct ble_gatt_attr { uint16_t handle; uint16_t offset; struct os_mbuf om; };</p>
<p class="">BLE gatt characteristic struct. struct ble_gatt_chr { uint16_t def_handle; uint16_t val_handle; uint8_t properties; ble_uuid_any_t uuid; };</p>
<p class="">BLE gatt description for callback. struct ble_gatt_dsc { uint16_t handle; ble_uuid_any_t uuid; };</p>
<p class="">BLE gatt MTU callback function type. typedef int ble_gatt_mtu_fn(uint16_t conn_handle, const struct ble_gatt_error error, uint16_t mtu, void arg);</p>
<p class="">BLE gatt discovery services callback function type. typedef int ble_gatt_disc_svc_fn(uint16_t conn_handle, const struct ble_gatt_error error, const struct ble_gatt_svc service, void arg);</p>
<p class="">The host will free the attribute mbuf automatically after the callback is executed. The application can take ownership of the mbuf and prevent it from being freed by assigning NULL to attr-&gt;om. typedef int ble_gatt_attr_fn(uint16_t conn_handle, const struct ble_gatt_error error, struct ble_gatt_attr attr, void arg);</p>
<p class="">BLE gatt discovery characteristic callback function type. typedef int ble_gatt_chr_fn(uint16_t conn_handle, const struct ble_gatt_error error, const struct ble_gatt_chr chr, void arg);</p>
<p class="">BLE gatt discovery descriptions callback function type. typedef int ble_gatt_dsc_fn(uint16_t conn_handle, const struct ble_gatt_error error, uint16_t chr_def_handle, const struct ble_gatt_dsc dsc, void arg);</p>
<p class="">Callback function type after characteristic is read or written. typedef int ble_gatt_access_fn(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt ctxt, void arg);</p>
<p class="">struct ble_gatt_chr_def { </p><pre class="fragment">  Pointer to characteristic UUID; use BLE_UUIDxx_DECLARE macros to declare
  proper UUID; NULL if there are no more characteristics in the service.

const ble_uuid_t uuid;

  Callback that gets executed when this characteristic is read or
  written.

ble_gatt_access_fn access_cb;

Optional argument for callback. 
void arg;


  Array of this characteristic's descriptors.  NULL if no descriptors.
  Do not include CCCD; it gets added automatically if this
  characteristic's notify or indicate flag is set.

struct ble_gatt_dsc_def descriptors;

Specifies the set of permitted operations for this characteristic. 
ble_gatt_chr_flags flags;

Specifies minimum required key size to access this characteristic. 
uint8_t min_key_size;


  At registration time, this is filled in with the characteristic's value
  attribute handle.

uint16_t val_handle;
</pre><p> };</p>
<p class="">struct ble_gatt_svc_def { </p><pre class="fragment">  One of the following:
      o BLE_GATT_SVC_TYPE_PRIMARY - primary service
      o BLE_GATT_SVC_TYPE_SECONDARY - secondary service
      o 0 - No more services in this array.

uint8_t type;


  Pointer to service UUID; use BLE_UUIDxx_DECLARE macros to declare
  proper UUID; NULL if there are no more characteristics in the service.

const ble_uuid_t uuid;


  Array of pointers to other service definitions.  These services are
  reported as "included services" during service discovery.  Terminate the
  array with NULL.

const struct ble_gatt_svc_def includes;


  Array of characteristic definitions corresponding to characteristics
  belonging to this service.

const struct ble_gatt_chr_def characteristics;
</pre><p> }; </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Comms.html">Comms</a></li>
    <li class="footer">Generated on Wed Aug 29 2018 10:21:28 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
